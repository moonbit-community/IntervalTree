// Generated using `moon info`, DON'T EDIT IT
package "kesmeey/IntervalTree"

// Values
fn[V : Compare, D] balance(Node[V, D]) -> Unit

fn default_options() -> IntervalOptions

fn[V : Compare] endpoints_geq(V, V, IntervalType) -> Bool

fn[V : Compare] endpoints_leq(V, V, IntervalType) -> Bool

fn[V : Compare] endpoints_overlap(V, V, IntervalType) -> Bool

fn[V : Compare, D] find_contained_helper(Node[V, D], Interval[V], Array[IntervalMatch[V, D]], IntervalType) -> Unit

fn[V : Compare, D] find_exact_helper(Node[V, D], Interval[V]) -> Node[V, D]?

fn[V, D] find_min(Node[V, D]) -> Node[V, D]

fn[V : Compare, D] find_overlaps_helper(Node[V, D], Interval[V], Array[IntervalMatch[V, D]], IntervalType) -> Unit

fn[V : Compare, D] from_array(Array[(Interval[V], D)], options? : IntervalOptions) -> T[V, D]

fn[V, D] get_balance_factor(Node[V, D]) -> Int

fn[V, D, R] in_order_traverse(Node[V, D]?, (Node[V, D]) -> R, R) -> R

fn[V : Compare, D] insert_node(Node[V, D], Node[V, D]) -> Bool

fn[V : Compare] interval_contains(Interval[V], Interval[V], interval_type? : IntervalType) -> Bool

fn[V : Compare] intervals_overlap(Interval[V], Interval[V], interval_type? : IntervalType) -> Bool

fn[V : Compare] is_valid_interval(Interval[V]) -> Bool

fn[V : Compare, D] left_rotate(Node[V, D]) -> Unit

fn[T : Compare] make_interval(T, T) -> Interval[T]

fn[V, D] new() -> T[V, D]

fn[V, D] new_with_options(IntervalOptions) -> T[V, D]

fn[V : Compare, D] remove_node(Node[V, D]?, Interval[V]) -> RemoveResult[V, D]

fn[V : Compare, D] right_rotate(Node[V, D]) -> Unit

fn[V : Compare, D] singleton(Interval[V], D, options? : IntervalOptions) -> T[V, D]

fn[V : Compare, D] update_height_and_max_high(Node[V, D]) -> Unit

// Errors

// Types and methods
pub struct Interval[T] {
  low : T
  high : T
}
impl[T : Eq] Eq for Interval[T]
impl[T : Show] Show for Interval[T]

pub struct IntervalMatch[T, D] {
  interval : Interval[T]
  data : D
}
impl[T : Eq, D : Eq] Eq for IntervalMatch[T, D]
impl[T : Show, D : Show] Show for IntervalMatch[T, D]

pub struct IntervalOptions {
  interval_type : IntervalType
  allow_duplicates : Bool
}
impl Eq for IntervalOptions
impl Show for IntervalOptions

pub(all) enum IntervalType {
  Closed
  Open
  LeftClosed
  RightClosed
}
impl Eq for IntervalType
impl Show for IntervalType

pub struct Node[V, D] {
  mut interval : Interval[V]
  mut data : D
  mut max_high : V
  mut left : Node[V, D]?
  mut right : Node[V, D]?
  mut height : Int
}
impl[V : Eq, D : Eq] Eq for Node[V, D]
impl[V : Show, D : Show] Show for Node[V, D]

pub struct RemoveResult[V, D] {
  node : Node[V, D]?
  removed : Bool
}

pub struct T[V, D] {
  mut root : Node[V, D]?
  mut size : Int
  options : IntervalOptions
}
fn[V, D] T::clear(Self[V, D]) -> Unit
fn[V : Compare, D] T::contains(Self[V, D], Interval[V]) -> Bool
fn[V, D] T::each(Self[V, D], (Interval[V], D) -> Unit) -> Unit
fn[V, D] T::eachi(Self[V, D], (Int, Interval[V], D) -> Unit) -> Unit
fn[V : Compare, D] T::find_contained(Self[V, D], Interval[V]) -> Array[IntervalMatch[V, D]]
fn[V : Compare, D] T::find_exact(Self[V, D], Interval[V]) -> Node[V, D]?
fn[V : Compare, D] T::find_overlaps(Self[V, D], Interval[V]) -> Array[IntervalMatch[V, D]]
fn[V : Compare, D] T::insert(Self[V, D], Interval[V], D) -> Bool
fn[V, D] T::is_empty(Self[V, D]) -> Bool
fn[V, D] T::op_get(Self[V, D], Int) -> IntervalMatch[V, D]
fn[V : Compare, D] T::remove(Self[V, D], Interval[V]) -> Bool
fn[V, D] T::size(Self[V, D]) -> Int
fn[V, D] T::to_array(Self[V, D]) -> Array[IntervalMatch[V, D]]
impl[V, D] Show for T[V, D]

// Type aliases

// Traits

